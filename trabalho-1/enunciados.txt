TRABALHO 1
Implementar computacionalmente, em linguagem acordada com o professor,
um programa que seja capaz de:
a) (PontuaÃ§Ã£o: 2,5) Aceitar, como entrada fornecida pelo usuÃ¡rio, alfabetos
formatados segundo formalismo da teoria de conjuntos, isto Ã©, cada
sÃ­mbolo deve ser separado por uma vÃ­rgula e devem estar dentro de
chaves. Os sÃ­mbolos aceitos pelo programa devem ser somente letras e
dÃ­gitos numÃ©ricos. NÃ£o Ã© permitido sÃ­mbolos repetidos no alfabeto.
EspaÃ§os devem permitidos como entrada, mas devem ser ignorados, ou
seja, nÃ£o sÃ£o sÃ­mbolos do alfabeto.
Exemplos:
1) {a,b,c}
2) {0,1}
3) { a , b , 0 , 1 }
b) (PontuaÃ§Ã£o: 2,5) Realizar uniÃ£o dos alfabetos entrados pelo usuÃ¡rio. O
Resultado da uniÃ£o nÃ£o pode ter sÃ­mbolos repetidos.
c) (PontuaÃ§Ã£o: 2,5) Verificar sobre quais alfabetos, dentre os entrados pelo
usuÃ¡rio, uma sequÃªncia de sÃ­mbolos, tambÃ©m fornecida pelo usuÃ¡rio, Ã©
palavra.
d) (PontuaÃ§Ã£o: 2,5) Determinar os prefixos, sufixos e subpalavras de uma
palavra. O programa deve: eliminar prefixos repetidos; eliminar sufixos
repetidos; eliminar supalavras repetidas. Utilize o sÃ­mbolo representado
por 136 do cÃ³digo ASCII para representar a palavra vazia.
Abaixo estÃ¡ o screenshot de um exemplo de programa (disponÃ­vel no moodle)
que atende a todos os requisitos deste trabalho, que deve ser apresentado no
final do semestre





TRABALHO 2
Implementar computacionalmente, em linguagem acordada com o professor, um
programa que reconheÃ§a a linguagem denotada pela linguagem regular:
b(a+b)b+(a+b)bb(a+b)+(a+b)(a+b)b(&+(a+b)*b)(a+b)(a+b)
ObservaÃ§Ã£o: o sÃ­mbolo â€˜&â€™ Ã© a palavra vazia. Foi utilizado este sÃ­mbolo na expressÃ£o regular
anterior para que possa ser utilizada na â€œAplicaÃ§Ã£o que converte expressÃ£o regular em AFDâ€,
disponibilizada no moodle, uma vez que esta aplicaÃ§Ã£o nÃ£o aceita o sÃ­mbolo Îµ. Utilize essa
aplicaÃ§Ã£o para gerar o AFD a ser implementado.
Para tanto, vocÃª deve projetar o AFD da linguagem, que deverÃ¡ sem apresentado
no programa ou em arquivo pdf. Em seguida, implementar em cÃ³digo-fonte a
funÃ§Ã£o de transiÃ§Ã£o do AFD e a funÃ§Ã£o de transiÃ§Ã£o estendida.
Definimos Î´, funÃ§Ã£o de transiÃ§Ã£o estendida, por induÃ§Ã£o sobre o comprimento
da palavra de entrada.
â€¢ BASE: Î´(q,Îµ)=q
Isto Ã©, se estamos no estado q e lemos nenhuma entrada, entÃ£o ainda
continuamos no estado q.
â€¢ INDUÃ‡ÃƒO: Suponha que w Ã© uma palavra da forma xa, ou seja, a Ã© o
Ãºltimo sÃ­mbolo de w, e x Ã© a palavra que consiste em tudo, menos o Ãºltimo
sÃ­mbolo. Por exemplo, w=1101 Ã© desmembrado em x=110 e a=1. Assim, o
passo de induÃ§Ã£o Ã©:
Î´(q,w) = Î´(Î´(q,x),a)


TRABALHO 4
Implementar computacionalmente, em linguagem acordada com o professor, um
programa que reconheÃ§a a linguagem denotada pela linguagem regular:
(a+b)*a(a+b)(a+b)
Para tanto, vocÃª deve projetar o AFN da linguagem, que deverÃ¡ sem apresentado
no programa ou em arquivo pdf. Em seguida, implementar em cÃ³digo-fonte a
funÃ§Ã£o de transiÃ§Ã£o do AFN e a funÃ§Ã£o de transiÃ§Ã£o estendida.
Definimos Î´, funÃ§Ã£o de transiÃ§Ã£o estendida, por induÃ§Ã£o sobre o comprimento
da palavra de entrada.
â€¢ BASE: Î´(q,Îµ)=q
Isto Ã©, se estamos no estado q e lemos nenhuma entrada, entÃ£o ainda
continuamos no estado q.
â€¢ INDUÃ‡ÃƒO: Suponha que w Ã© uma palavra da forma xa, ou seja, a Ã© o
Ãºltimo sÃ­mbolo de w, e x Ã© a palavra que consiste em tudo, menos o Ãºltimo
sÃ­mbolo. Por exemplo, w=1101 Ã© desmembrado em x=110 e a=1. Assim, o
passo de induÃ§Ã£o Ã©:
Î´(q,w) = Î´(Î´(q,x),a)
No entanto, lembre-se que em AFN o retorno de uma funÃ§Ã£o de transiÃ§Ã£o
Î´ Ã© um conjunto de estados. Por isso, considere que Î´(q,w)={p1,p2,â€¦,pk}.
Assim,
â‹ƒ ï¤(ğ‘ğ‘–
, ğ‘) = {ğ‘Ÿ1, ğ‘Ÿ2, â€¦ , ğ‘Ÿğ‘˜}
ğ‘˜
ğ‘–=1
EntÃ£o, ï¤(q,w)={ğ‘Ÿ1, ğ‘Ÿ2, â€¦ , ğ‘Ÿğ‘˜}. De modo menos formal, calculamos ï¤(q,w)
calculando primeiro ï¤(q,x) e depois seguinto todas as transiÃ§Ãµes de
qualquer destes estados que seja rotulada por a.
